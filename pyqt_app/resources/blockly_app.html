<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Robot Blockly Workspace</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        html, body { height: 100%; margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #app { display: flex; flex-direction: column; height: 100%; }
        #workspace { position: relative; display: flex; flex-direction: column; flex: 1 1 auto; min-height: 0; }
        #log-panel { border-top: 1px solid #ccc; padding: 12px; box-sizing: border-box; flex: 0 0 140px; display: flex; flex-direction: column; }
        #log-panel h2 { margin: 0 0 8px; }
        #log { white-space: pre-wrap; word-break: break-word; flex: 1 1 auto; margin: 0; overflow-y: auto; }
        .button-row { margin: 10px 6px; display: flex; gap: 8px; flex-wrap: wrap; }
        button { padding: 8px 12px; }
        #blocklyDiv { flex: 1 1 auto; width: 100%; min-height: 0; }
    </style>
    <link rel="stylesheet" href="vendor/blockly/blockly.css">
    <script src="blockly_loader.js"></script>
    <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
</head>
<body>
    <div id="app">
        <div id="workspace">
            <div class="button-row">
                <!-- <button id="btn-export">Export IR JSON</button> -->
                <button id="btn-clear">Clear Workspace</button>
                <button id="btn-zoom-in" title="Zoom in">Zoom In</button>
                <button id="btn-zoom-out" title="Zoom out">Zoom Out</button>
            </div>
            <div id="blocklyDiv"></div>
            <xml id="toolbox" style="display: none"></xml>
        </div>
        <div id="log-panel">
            <h4>Status</h4>
            <pre id="log">Initializing…</pre>
        </div>
    </div>
    <script>
        let bridge = null;
        let workspace = null;

        function initChannel() {
            new QWebChannel(qt.webChannelTransport, function(channel) {
                bridge = channel.objects.robotBridge;
                bridge.validationResult.connect(onValidationResult);
                bridge.codeGenerated.connect(onCodeGenerated);
                bridge.generationFailed.connect(onGenerationFailed);
                appendLog('Bridge connected.');
                emitWorkspace();
            });
        }

       function initBlockly() {
            if (typeof Blockly === 'undefined') {
                appendLog('Blockly library is unavailable. Check network access or bundle a local copy.');
                return;
            }
            const toolboxDef = JSON.parse(Blockly.RobotToolbox);
            workspace = Blockly.inject('blocklyDiv', {
                toolbox: toolboxDef,
                scrollbars: true,
                trashcan: true,
                renderer: 'zelos',
                media: 'vendor/blockly/media/'
            });

            workspace.addChangeListener(handleWorkspaceChange);
            appendLog('Workspace ready.');
        }

        function handleWorkspaceChange(event) {
            if (event.type === Blockly.Events.BLOCK_CREATE) {
                // Ensure the block ID stays in sync with IR command IDs.
                const block = workspace.getBlockById(event.blockId);
                if (block) {
                    block.data = block.id;
                }
            }
            // Debounce/aggregate? For now emit on every meaningful change.
            if (event.type !== Blockly.Events.VIEWPORT_CHANGE) {
                emitWorkspace();
            }
        }

        function emitWorkspace() {
            if (!bridge || !workspace) {
                return;
            }
            try {
                const irDocument = Blockly.RobotIR.workspaceToDocument(workspace);
                const jsonText = JSON.stringify(irDocument, null, 2);
                bridge.updateIrJson(jsonText);
            } catch (err) {
                appendLog('Generator error: ' + err);
            }
        }

        function highlightBlocks(ids) {
            if (!workspace) {
                return;
            }
            workspace.highlightBlock(null);
            ids.forEach(id => {
                const block = workspace.getBlockById(id);
                if (block) {
                    workspace.highlightBlock(id);
                }
            });
        }

        function onValidationResult(isValid, errors, warnings) {
            if (isValid) {
                appendLog('IR valid.');
                highlightBlocks([]);
                if (warnings.length) {
                    appendLog('Warnings:\n' + warnings.join('\n'));
                }
            } else {
                appendLog('Validation failed:\n' + errors.join('\n'));
                // Extract block IDs from messages (assuming they mention sequence indices).
                highlightBlocks(extractIdsFromErrors(errors));
            }
        }

        function onCodeGenerated(source) {
            appendLog('C# generated. Check the desktop panel.');
        }

        function onGenerationFailed(message) {
            appendLog('Generation failed: ' + message);
        }

        function appendLog(message) {
            const log = document.getElementById('log');
            log.textContent = message;
        }

        function extractIdsFromErrors(errors) {
            const ids = [];
            const regex = /'(.*?)'/;
            errors.forEach(msg => {
                const match = msg.match(regex);
                if (match && match[1]) {
                    ids.push(match[1]);
                }
            });
            return ids;
        }

        // document.getElementById('btn-export').addEventListener('click', function() {
        //     if (!workspace) { return; }
        //     const doc = Blockly.RobotIR.workspaceToDocument(workspace);
        //     const text = JSON.stringify(doc, null, 2);
        //     const blob = new Blob([text], { type: 'application/json' });
        //     const url = URL.createObjectURL(blob);
        //     const a = document.createElement('a');
        //     a.href = url;
        //     a.download = 'robot_workflow.json';
        //     a.click();
        //     URL.revokeObjectURL(url);
        // });

        document.getElementById('btn-clear').addEventListener('click', function() {
            workspace.clear();
        });

        document.getElementById('btn-zoom-in').addEventListener('click', function() {
            if (!workspace) { return; }
            workspace.zoomCenter(1);
        });

        document.getElementById('btn-zoom-out').addEventListener('click', function() {
            if (!workspace) { return; }
            workspace.zoomCenter(-1);
        });

        window.addEventListener('RobotBlocklyReady', function() {
            initBlockly();
        });

        window.addEventListener('RobotBlocklyFailed', function() {
            appendLog('Failed to load Blockly assets.');
        });

        document.addEventListener('DOMContentLoaded', function() {
            appendLog('Loading Blockly assets…');
            initChannel();
        });
    </script>
</body>
</html>
